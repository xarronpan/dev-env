# 配置
设置全局账号。这些信息在git中commit中会被进行填写
公司gitlab会检查 用户名称 以及 邮件地址是否合法。
```bash
git config --global user.email "panxiangrong@yy.com"
git config --global user.name "panxiangrong"```

设置自动保存密码
```bash
git config --global credential.helper store```

# 原理
https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248
## 仓库
仓库在git中是一个用户间进行协作开发的代码管理单位。一个仓库中的用户需要创建不同的代码版本，进行merge，然后提交仓库等操作。一个仓库中的用户之间的开发关联关系较为紧密。
git中的仓库包括了本地仓库以及远程仓库。本地仓库是指用户进行本地开发的代码管理单元。远程仓库则是只后台对应的一个代码管理单元。
一个用户的本地仓库中可以加入几个不同的远程仓库，这样子用户就可以同时对几个不同远程仓库中的内容进行开发管理(创建分支，合并分支，对比等)
存在这种使用方法的主要原因，是为了支持 不同仓库间的 协同开发。在开源项目中，很多的代码管理需要不是一个仓库的管理需求，而是仓库间进行协作管理的需求
因为一个仓库中的协作关系，权限关系非常紧密，同一个仓库中的开发协作关系不适用于开源的项目环境。开源的项目环境中，不同开发者之间的关联关系是非常松散的，只有在必要的时候，才会存在代码的合并需求。
一个仓库的管理者，不可能给所有这些想参与到开源项目的用户，都开放对应的权限，开源项目的参与者才能使用代码管理工具来进行开发。
所以github这类仓库管理系统，支持fork，pullrequest这类仓库间的协同功能。当用户需要参与一个项目时，其只需要fork一个仓库出来。然后在这个仓库中进行可能较为紧密的协作开发。而当fork出来的仓库形成了规模之后，
才发起pull request，将一个仓库中的内容提交到另外一个仓库中。这些使用场景，完全不同于svn这类集中式的代码管理工具所定位的功能范围。
而git的定位则是能够为这类协作需求，提供最为基础的能力支持。
git由于是从开源项目项目管理需求中所诞生出来的vms，所以这种需求深刻地影响了git使用概念，以及一大堆的设计决策。

## 本地分支、远程仓库分支、远程仓库本地追踪分支
### 概述
由于git的定位是能够在不连接服务器的情况下都能够工作的版本管理工具，所以其核心概念是代码版本都是本地的，所以存在着本地分支的概念。
git的全部编辑操作都是在本地分支中进行的，包括了修改，合并，从某个分支中进行创建等。
又在进行协作开发时，代码最终需要提交到远程仓库之中，因而在远程仓库中，实际上是存在 代码的版本的，所以存在着另外一个核心概念远程分支。
git通过本地分支与远程分支的绑定操作，并且指定pull，push等操作，来实现将代码同步到服务器上。
远程分支与本地分支发生交互的概念非常简单。
  a) 从远程分支获取最新内容到本地分支
    就是将本地分支与远程分支进行merge的操作。将远程分支的修改merge到本地分支

  b) 从本地分支推送内容到远程分支
    就是将远程分支与本地分支进行merge的操作。将本地分支的修改merge到远程分支
    只要本地分支与远程分支符合因果的提交关系，就可以进行推送。
    如果不符合因果提交关系，则通过远程分支和本地分支的merge操作使两个分支存在因果关系，然后进行推送

我们可以发现远程分支的获取/推送操作实际可以理解成本地分支与远程分支之间的merge操作, 实际并没有引入新的概念
而且, 在git的设计中，远程仓库其实也就是一个普通的git客户端，并不是一个很重的东西。git的设计本质上是点对点的
git会将远程的分支，在用户的本地创建一个不能进行本地修改的 本地分支，我们称之为 远程本地追踪分支 。远程本地追踪分支 的名称为 <remote>/<branch>。其中remote一般为origin。
remote实际上代表的就是一个远程仓库地址的别名, 而上面描述的本地分支与远程分支之间的merge操作，就靠远程本地追踪分支来进行管理
在一些很变态的场合下，同一个代码仓库，可能会有若干个不同的远程地址仓库与之对应，所以需要一个 远程后台 的名称来进行区分。我们可以认为remote就是一个 远程仓库地址 的别名即可。
git采用这种设计的主要考虑是灵活性，一个仓库中的东西可以与任意数目的远程仓库的内容进行关联，这样子我们就可以很灵活地对不同的远程仓库中的内容。比如说 github 中常用的fork的能力，就需要采用这种能力来进行管理。
用户可能需要对基于一定关系的若干个不同的仓库进行merge等操作。这样子就需要用户能够在同一个本地仓库中去增加几个不同的远程分支。
remote可以在git clone的时候指定-o参数来进行指定，比如下面的例子：
```bash
git clone -o booyah```

其中 booyah 替代了origin 作为 remote的名称。这里也可以看出来 remote的名称只是git客户端本地加上去的。在git的后台，分支名称是没有 remote 这个前缀的。
远程本地追踪分支 与 其他的本地分支的特性，除了不能直接修改，与其他本地分支没有本质差异。因而我们可以基于 远程本地追踪分支 创建我们自己的分支，然后进行我们自己的修改。
同一个分支对应的不同远程分支，在客户端的本地也是共享同一个版本树的。

### 更新所有远程本地追踪分支
```bash
git fetch <remote>```
可以通过上面的命令，可以将remote仓库上的所有分支中的内容，下载到本地，并且写入到远程本地追踪分支中。
这个命令并不会更新你自己的本地分支中的内容，哪怕本地分支已经与远程仓库分支之间已经建立过了追踪关系。

### 将本地分支推送到远程
```bash
git push <remote> <remote_branch_name>```
这个命令会将本地的分支 remote_branch_name 分支的内容 推送到 remote 所对应的远程仓库中。远程仓库中如果没有这个分支，则会创建分支。否则会更新远程仓库分支中的内容。
本地的分支名称与 远程仓库分支名称之间 没有必然联系。通过这种方式，我们就可以将本地分支中的内容给写入到 远程仓库中的分支中，从而建立了本地分支与远程仓库分支之间的一个方向的数据联系。
当git发现本地分支的版本关系与远程仓库中的分支关系不正确时会失败。此时用户需要自行发起一个等价于git pull的请求，将远程仓库分支中的东西merge到本地分支后，才能进行提交。
详细见 (获取远程仓库分支的内容) 中的说明

### 建立追踪分支
```bash
git checkout --track <remote>/<remote_branch_name>```
这个命令用于将 远程仓库本地追踪分支与 本地分支之间建立一个 "追踪" 的关联关系。追踪关联关系的作用在于 git pull ，git push 这类请求不需要再带额外的参数，方便用户的日常使用
当git pull，git push使用更加详细的参数时，是可以不需要建立 追踪 关系，也可以将本地分支中的内容与 远程仓库发生关系的。这里可以见到 追踪关系只是在用户客户端上存在。
一般而言，当用时使用 check out，pull等命令时，会自动建立 追踪关系，不需要手动建立关联关系

git branch -vv
能够显示本地分支与远程仓库分支之间的追踪关系

### 获取远程仓库分支的内容
```bash
git pull```
git pull命令的本质，就是一个 git fetch 命令，外加一个 git merge 命令。其本质是先从 远程仓库 中将代码数据同步到本地的 远程仓库本地追踪分支中。然后 使用当前本地分支，与远程仓库追踪分支发起一个merge操作
当本地分支与远程仓库分支建立了追踪关系之后，pull请求就会找到 本地分支 中的 追踪的远程仓库分支，发起merge请求。

### 总结
git本地分支与远程仓库分支发生关联关系就只有pull与push的关联关系。一个负责将远程仓库的数据同步到本地。一个将本地分支的数据推送到远程。再加上本地分支的代码管理能力，从功能上说就已经是完备的了。
本地分支与远程仓库分支之间的关联关系非常松散。一个本地分支可以push到任意一个远程仓库分支中。一个本地分支也可以与任何一个远程仓库分支进行pull操作 (就将任意一个远程仓库分支中的内容给合并到本地分支中)
git的核心概念其实非常少，也非常简练
git的心理模型与svn这类系统的心理模型相差很远，因而使用svn的心理模型来套到git上，就很难进行理解。
虽然如此，由于我们大多数时间都在类似svn的环境下面工作，下面还是会给出svn上常见需求对应的git命令。
git远程分支的官方解释，可以参考下面的文档:
https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches

## 分布式vms
git是一个分布式vms。这意味着git不需要连接到服务器就可以直接在本地进行开发。所以git上面的版本管理功能，全部都是基于本地的。这点和svn这类vms有很大的区别。
我们可以想象使用git，就像在本地安装了一个svn服务器一样。每次编写的代码，提交的时候都是先提交到本地。然后branch，merge等能力也全部是应用在本地分支上的。

## 暂存区/提交修改
git的暂存区存在的意义在于能够支持原子性的提交，从而使得我们进行版本回滚的时候，能够得到一个有意义的版本历史: https://www.zhihu.com/question/19946553
这个特性最早由svn进行引入，git进行了借鉴。所以在git中工作的best practice是每次进行一次有意义的修改，然后统一进行一次提交
这样子每次所提交的内容就不应该体积过大，并且有明确的修改目标
事实上对于职业的开发人员来将，commit log其实与代码的注释一样重要。其在很大程度上能够提供出代码如果开发构建的整个过程信息，有利于代码的维护人员，代码的学习人员去学习被增加的代码的内涵
而不需要仅仅使用代码的当前版本来进行猜测。这样子提交历史中的信息，其实也应该是区别于代码本身的信息。并且需要说明清楚代码修改的目的
我们也可以对暂存区中的内容进行回滚。这些操作使用vim fugitive来进行处理会更加简单
https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576
git另外一个区别于svn的地方，在于当我们需要进行提交的时候，都是提交修改。我感觉这点设计奇怪的唯一原因，是我之前被svn洗了脑，认为svn的工作方式才是正确的。
事实上，如果我们需要向仓库中提交东西，则我们最为简单直接了当的方式就是告诉仓库我们修改了什么东西即可。对于增加/修改/删除文件，因为都是修改的概念，所以操作上面都是一视同仁的。
其结果就是操作非常统一简单。而svn这类系统给用户的界面，则是对于增加与删除文件有额外的操作。一个文件需要提交到仓库，首先需要一个add操作。add完的文件才能进行commit。
这里实际上强行引入一个将文件与仓库建立关联关系的概念与操作。而事实上这个操作是多余的。如果你将修改过的东西提交过给仓库，仓库自然知道哪些文件需要进行追踪管理。
svn等去强行地将一个对于用户多余的东西塞给了用户，然后用户都以为只能按这种方式来工作。然后git要将大家错误的概念给纠正过来时，比如我就觉得很奇怪。
所以git在提交代码到仓库的界面上，通过提交修改的方案， 对于用户需要理解的概念最少的方式提供了最为合理的方案。所以不得不说git在绝大多数方面的功能 (除了回滚远程分支这类没有内置的常用功能外)，都要比svn要好。

## 全局版本号/snapshot
vms的主要任务是管理代码的版本。如上面的分析指出，git的整个仓库管理策略，是一个本地仓库可以对应多个不同的远程仓库。也就是说代码分支的版本号是需要跨不同的远程仓库进行分支合并管理的。
这就意味着像svn系统中的每个仓库统一给出分支的版本号的方案是不现实的。因为不同远程仓库中的代码需要在某个本地仓库中统一进行版本管理。所以git的策略是对于一个项目而言(项目可能在若干个不同的远程仓库中)，
版本号是全局唯一的。每个分支的一个commit基本上都对应一个版本，在最为理想的情况下，我们可以通过这个commit中全部代码的二进制内容来计算出一个sha1值来作为这个commit的版本号。
这样子就解决了git版本号能够跨域不同远程仓库的问题。也就是git是对一个分支的commit的快照来进行版本管理的。这个方案最重要的好处是简单，也是vms系统的基本设计。
我们可以想象一个项目为一个单一文件，而项目中的每个代码文件都只是项目这个大文件的一部分。而我们需要管理的只是这真个整体的大文件。事实上，单一的文件版本本身是没有意义的。vms的本质需求就是要建立项目中
不同代码文件之间的版本联系。由于我们不可能每次commit的时候都去计算全部二进制文件的sha1值，否则commit操作就会变得很慢。一个折衷的做法应该是以这个commit所基于的版本的sha1值，再加上本次提交所涉及的
二进制内容统一算一个sha1，在很大程度上也是在项目中也是唯一的。因为这就等价于通过一个sha1来代表一个base版本，再增加相关的修改，就能代表整个代码版本。
git实际所采用的计算方案更加流氓，就是上一个commit的sha1再加auther再加时间戳。这是因为同一个author在同一个时间点，基本上只能发生一次唯一的提交。这个方案比刚才提到的方案效率和复杂度都下降了一个级别。

## 分支管理
如果管理一个分支中两个相邻commit之间的数据也是git区别于其他vms的主要特征。在类似svn这类系统中，一个分支中的两个commit之间，保存的是代码文件的diff。这个方案最为重要的特征是节省空间。
在svn这类系统盛行时，大量拉取分支进行代码开发，合并还不是一个常态。而事实证明，独立的代码分支feature的开发方式是一个优秀的实践标准。svn这种方案的主要问题是分支相关的操作慢。
因为我们只存储了commit之间的diff数据，所以我们需要频繁快速的在分支之间切换时，就需要将分支的差异diff都给应用一遍，才能切换分支。因为这个原因，svn是不支持分支切换操作的。如果你想在多个分支中进行开发
你只能将多个不同的分支的代码都checkout到本地。所以创建分支的速度也是很慢的，需要将整个commit的diff都给应用一遍。这样子其实违背了用户真正的需求。用户想要的是快速地在几个目录中切换文件。
git通过在两个相应的commit之间，存储发生了变化的文件的完整snapshot来解决这个问题。git的元信息会记录commit之间，哪些文件发生了修改，并且存储每个commit发生了修改的文件的完整版本。
这种做法的好处就是能够快速地在分支上进行切换，分支创建，版本跳转，因为此时需要做的只是找到发生了变更的文件，然后load对应的版本即可。这个方案的缺点在于浪费空间。
但是一般的项目代码本身体积较小，而且目前存储器的磁盘成本相当低，再加上我们有压缩算法，所以应该是可以接受的。这个方案导致的其中一个后果，就是首次从远程仓库建立本地仓库时时间会比较长。
为了优化这个事情，远程仓库中应该尽量压缩没有必要的中间commit，能够节省建立仓库的时间。
两个commit之间没有发生变化的部分，是没有必要也存储一个完整版本的。毕竟一个commit就要将这个项目的代码都拷贝一遍，对于空间以及commit的效率影响都很大，git显然是不会这样子做的

## HEAD
指向当前被checkout分支的当前编辑位置的版本指针称为HEAD。这个术语在其他的vms中可能是不一样的

## commit log
如何查看git log，了解项目版本变更，对应的提交人信息
首先，在远程仓库中所看到某个分支的提交日志，必定是某个本地分支上面的commit log。
如果提交日志中一直没有出现过版本的合并的话，则整个提交日志的graph是一条直线
如果提交日志中出现过merge，则graph中会出现一条分支线。分支线上的提交日志可以认为就是分支上面的修改。
分支线的开始则表示分支是基于哪个版本分离出来的。
总之，commit log的graph所展现出来的信息，非常清晰地展现了一个分支上的提交的所有结构。
其即是对应于 git book 上面的的分支图 https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging
注意到由于git中的版本号都是全局唯一的，所以这种分支图能够展现不同仓库的代码分支进行merge之后的复杂结构。
而且注意到commit log中实际上是会展现本地分支的信息的。
实际上git这种commit log，graph的展现方式才是合理而且靠谱的。我之前总是在往svn的使用经验上面靠，所以感觉到难以理解。

## 设计理念总结
总的而言，git的设计理念是提供机制，而不是产品化的接口给用户。所以我们在常用命令中一节会发现很多在svn上面能够一个命令就能搞掂的事情，在git上面需要多个命令的组合才能完成。
在易用性和灵活性上，git选择了灵活性。这意味着git提供了很多的机制，但是当用户去使用这个工具时，需要理解这些机制背后的概念，需要较多的学习成本。
但是另外一个方面，因而设计本身聚焦于几个核心概念而不是用户侧的需求，所以git本身非常简单、内聚，从某种角度上面讲，对于基础操作的易用性反而提升了。只是用户的使用成本有所增加
github这类产品提供的则是基于git稳定机制的更加上层产品化的产品，提供了类似fork，pull request这类更加贴近于用户使用需求的功能。

设计产品有两个不同的思考方向：
基于策略来设计产品 ，也就是自顶向下，通过最终用户的需求来考虑设计产品，优先考虑产品的易用性
基于机制来设计产品，也就是自低向上，通过分析需求领域中的核心结构来分析系统所需要支持的机制，优先考虑产品的灵活性和功能稳定性
如何确定何时采用哪种策略，只能根据具体的产品，具体的需求场景来进行分析，并没有一个具体的答案。采用这两种方案都有成功的开源产品诞生。

若考虑的是以机制的方式提供能力给用户，本身具有灵活性，简单性(简单的缘故是设计系统时我们一直考虑的是如何能让机制运作起来，所以复杂度必定是可控的)，但是易用性较差。
这样子要考虑 在易用性的角度，能否提供出清晰简单的心理模型给用户。若可以，则设计出来的产品就同时具备了灵活性和易用性。
若心理模型过于复杂，则说明东西虽然灵活，但是用户明显是学习不会怎样子进行使用的，需要在灵活性上进行折衷，提供更易用但是没有那么灵活的产品

若是考虑一策略的方式提供能力给用户，其本身具备易用性，此时重点要考察的就是基于策略设计出来的产品，是否具备一定的灵活性，以及功能的稳定性，最好还要是复杂度可控的。
若可以，则设计出来的产品也就同时具备了易用性和灵活性以及简单性。
但是若发现做不到，则提供出来的产品复杂度太高，或者接口能力非常脆弱，反过来又会影响用户的易用性。此时只能反过来在易用性上做折衷，提供不那么易用，但是更加灵活、简单的技术方案
git是基于机制为核心来提供产品的，则我们发现其提供的机制简单清晰，因而其同时具备了灵活以及易用的特征。

# 常用命令
这里主要记录一些在公司开发的环境中经常会用到，但是在命令行中输入比较困难的命令
因为公司的开发环境就与svn的使用环境就是相同的，所以一般就是本地分支与远程仓库分支建立一对一的简单关系，然后进行简单的pull，push即可
其他经常使用的命令，直接在vi 中使用fugative插件来进行对应操作即可
```bash
git commit --amend    #补充提交文件为了避免commit log出现很多没有意义的提交历史
git branch -a         #列出全部的本地分支以及远程仓库本地追踪分支
git pull              #将远程分支的修改同步到本地分支
git push              #将本地分支的修改同步到远程分支
```
## 从仓库的本地分支中创建本地分支，切换到该分支，并且推送到远程分支
```bash
git checkout -b new_branch  #这个命令以当前本地分支为基准，创建新的本地分支，并且切换到新的本地分支。git checkout指切换分支，-b表示创建分支
git push --set-upstream origin new_branch
```

## 从仓库中拉取远程仓库分支，并且在本地创建本地分支
```bash
git fetch origin
git checkout -b new_branch --track origin/new_branch```

## 切换本地分支 (git中的分支切换必定是指切换本地分支)
```bash
git checkout target_branch```

## 将创建出来的本地分支，合并到另外一个本地分支中
注意任意两个分支都可以进行合并的
```bash
git checkout to_merge_branch           #git的合并还是基于本地分支来进行。首先切换到需要进行合并(修改)的分支
git merge target_branch                #将当且的分支，合并 target_branch 中的修改。如果target_branch中的东西是完全基于to_merge_branch的内容来修改的，则git只要移动版本指针即可完成merge
                                       #在git中称为fast-forward。
                                       #如果合并中发生冲突，则可以使用git status来定位冲突的位置，并且通过文件中的冲突标记来进行冲突合并。冲突标记已经很明确地标记出分支上的不同，因而不需要引入图形化的界面来进行解决
                                       #在vim中，也可以采用Gdiff的方式打开冲突文件来进行编辑。Gdiff的窗口是直接可以进行编辑的。
                                       #merge操作相当于对to_merge_branch的修改操作。所以如果需要确定合并的结果，此时使用git diff来对比即可
```
## 删除本地分支，并且同步到远程分支，使远程分支也被删除
```bash
git branch -d target_branch                 #删除本地分支
git push target_branch --delete serverfix   #删除远程仓库的分支。我们也可以在不删除本地分支的情况下，直接删除远程仓库中的分支。远程分支的target_branch不一定需要与本地的分支名相同
```
## 代码在本地分支中还没有同步远程分支，回滚到某个历史版本
```bash
git reset --hard sha1_version               #使head指针指向 sha1_version所指向的版本
```
若进行回滚之后，需要跳转到回滚之前的版本，需要使用上面相同的命令
但是需要找到回滚之前的版本号。使用git relog，能够找到所有的本地分支提交修改历史，并且有对应的sha1 版本号。找到后就可以进行混滚
```bash
git relog
```

## 本地分支中已经同步远程分支，回滚到某个历史版本
这个操作相对比较复杂。主要的原理是先将需要回滚到的目标版本给checkout出来一个回滚分支，然后在将 当前需要回滚的当前分支与 回滚分支 进行merge，再重新推送到远程分支中 
https://harttle.land/2018/03/12/reset-origin-without-force-push.html

## 在本地分支中移动，删除文件
### 删除文件
```bash
#因为git只追踪工作区中的修改，所以git add能够追踪所有的工作区修改。git rm命令等价于
# rm file_name
# git add file_name
git rm file_name
```
### 移动文件
```bash
#因为git只追踪工作区中的修改，所以git add能够追踪所有的工作区修改。git mv命令等价于
# mv old_file_name new_file_name
# git rm old_file_name
# git add new_file_name
git mv old_file_name new_file_name
```
## 打tag，将tag推送到远程仓库，从tag中拉分支
tag用于在git中标明重要的commit节点，一般用于标明release版本，是非常重要的git功能
tag分为标注tag以及轻量级tag。标注tag在git的远程仓库中就是一个完整的独立分支(这点和svn这类系统又是不一样的)
普通的git push命令不会将标注tag给推送到远程仓库。要将tag给同步到远程仓库，需要对每个独立的tag进行git push操作
tag在远程仓库中的性质，与一个普通的远程分支是完全一样的。
```bash
git tag -a <tag_name> -m "<tag_info>"        #在当前本地分支中打标注tag。打完tag后会生成一条新的commit到本地分支中
git push origin <tagname>                    #将当前本地分支中的 tagname 标签，推送远程仓库
git checkout -b new_branch_name <tagname>    #将tag中的拉出分支来进行开发
# git tag的详细操作说明请见:https://git-scm.com/book/en/v2/Git-Basics-Tagging
```
## rebase
https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase
rebase是一种merge的方式。普通的merge会在commit log的graph中产生一个分叉，而rebase的合并则等价于找打两个需要merge的分支的差别，打一个patch
然后在进行merge的分支上面进行应用。
rebase应用场景如下:
  假设主干还有分支的开发人员是两拨人，任务是相互独立的。此时分支的开发人员想要将自己的工作给合并到主干。
分支的开发人员首先将分支rebase到主干。这样子做的目的是为了将主干的修改先在分支上进行合并，并且commit log不会产生分支。
在分支rebase的时候，主干是不会有变化的。所以分支上的合并操作并不会影响到主干上的开发。
在分支rebase合并完成之后, 若master没有新的提交, 则分支的版本和master上的版本是存在这直接的前后关系的。这也是rebase "变基" 的含义，
分支将自己的提交历史"变"到了主干的HEAD上。
然后主干的开发人员不需要处理任何的冲突，fast-forward到分支上即可
  git merge应该也能做到刚才所提到的这些事情，使得在master开发的人员不需要自己做合并操作。这点对于协作性的开发是一个良好的实践。
只是此时提交的历史会形成分叉。
  已经被推送到仓库的分支不能进行rebase。这是因为rebase会改变commit log的结构, 导致commit log在远端仓库中不完整
```bash
git checkout target_branch
git rebase master 
#target_branch变基到master，指的是首先将target_branch的commit log变成master的commit log, 此时target_branch首先变成和master上的HEAD版本一样
#然后将target_branch与master分叉的之后的每一个commit, 都作为一个独立的patch, 在这个版本(也就是master的HEAD版本)上再次做提交。
#每次提交的时候，需要处理冲突。每次提交的时候会创建新的commit'，与原来的commit相对应, 并且commit的说明是一样的
#rebase -i可以改变commit', 使commit'的说明和commit不一样
#当target_branch上的每个commit都作为patch重新提交完之后, target branch就等于在版本上直接领先于master了
#所以此时就可以直接做fast-forward的合并了
git checkout master
git merge target_branch                   #master采用fast-forward的方式合并到target_branch
```
上面的命令将master合并target_branch中的内容
git rebase的详细操作说明请见: https://git-scm.com/book/en/v2/Git-Branching-Rebasing
